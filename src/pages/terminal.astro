---
// No server-side logic — pure client-side terminal
---
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>ZERO OS — Terminal</title>
  <meta name="description" content="ZERO OS interactive terminal interface" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet" />
  <style>
    *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

    html, body {
      height: 100%;
      overflow: hidden;
      background: #0a0a0a;
    }

    .terminal-screen {
      background: #0a0a0a;
      min-height: 100vh;
      height: 100vh;
      padding: 20px;
      padding-bottom: 80px;
      font-family: 'JetBrains Mono', 'DM Mono', 'Courier New', monospace;
      font-size: 14px;
      line-height: 1.6;
      color: #c8ff00;
      position: relative;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }

    .terminal-screen::before {
      content: '';
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: repeating-linear-gradient(
        0deg,
        rgba(0,0,0,0.15) 0px,
        rgba(0,0,0,0.15) 1px,
        transparent 1px,
        transparent 3px
      );
      pointer-events: none;
      z-index: 10;
    }

    .output-line { white-space: pre-wrap; word-break: break-word; }
    .output-line.dim { color: #5a6a00; }

    .input-line {
      display: flex;
      align-items: center;
      white-space: pre;
    }

    .prompt { color: #c8ff00; user-select: none; }

    #input {
      background: none;
      border: none;
      outline: none;
      color: #c8ff00;
      font-family: inherit;
      font-size: inherit;
      line-height: inherit;
      flex: 1;
      caret-color: #c8ff00;
      padding: 0;
    }

    .cursor-block {
      display: inline-block;
      width: 0.6em;
      height: 1.15em;
      background: #c8ff00;
      vertical-align: text-bottom;
      animation: blink 1s step-end infinite;
    }

    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0; }
    }

    .exit-hint {
      position: fixed;
      top: 10px;
      right: 16px;
      color: #3a4a00;
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      z-index: 20;
      user-select: none;
    }
    .exit-hint a { color: #5a6a00; text-decoration: none; }
    .exit-hint a:hover { color: #c8ff00; }

    @media (max-width: 768px) {
      .terminal-screen { font-size: 13px; padding: 14px; padding-bottom: 80px; }
      .input-line input { font-size: 16px; } /* prevents iOS zoom */
      .prompt { font-size: 0.85rem; }
    }
    @media (max-width: 375px) {
      .terminal-screen { font-size: 12px; padding: 10px; padding-bottom: 80px; }
    }
  </style>
</head>
<body>
  <div class="exit-hint"><a href="/">← back to site</a></div>
  <div class="terminal-screen" id="screen">
    <div id="output"></div>
    <div class="input-line" id="input-row">
      <span class="prompt">zero@system:~$&nbsp;</span>
      <input type="text" id="input" autocomplete="off" autocapitalize="none" spellcheck="false" autofocus />
    </div>
  </div>

  <script>
    const output = document.getElementById('output');
    const input = document.getElementById('input');
    const screen = document.getElementById('screen');
    const inputRow = document.getElementById('input-row');

    const MAX_LINES = 50;
    let history = JSON.parse(sessionStorage.getItem('term_history') || '[]');
    let historyIdx = history.length;
    let cache = {};
    let typing = false;

    function trimScrollback() {
      while (output.children.length > MAX_LINES) {
        output.removeChild(output.firstChild);
      }
    }

    function scrollBottom() {
      screen.scrollTop = screen.scrollHeight;
    }

    function printLine(text, cls) {
      const div = document.createElement('div');
      div.className = 'output-line' + (cls ? ' ' + cls : '');
      div.textContent = text;
      output.appendChild(div);
      trimScrollback();
      scrollBottom();
    }

    function typeLines(text, speed = 18) {
      return new Promise(resolve => {
        typing = true;
        inputRow.style.display = 'none';
        const lines = text.split('\n');
        let lineIdx = 0;
        let charIdx = 0;
        let currentDiv = null;

        function nextChar() {
          if (lineIdx >= lines.length) {
            typing = false;
            inputRow.style.display = 'flex';
            input.focus();
            scrollBottom();
            resolve();
            return;
          }
          if (!currentDiv) {
            currentDiv = document.createElement('div');
            currentDiv.className = 'output-line';
            output.appendChild(currentDiv);
            trimScrollback();
          }
          const line = lines[lineIdx];
          if (charIdx < line.length) {
            currentDiv.textContent += line[charIdx];
            charIdx++;
            setTimeout(nextChar, speed);
          } else {
            lineIdx++;
            charIdx = 0;
            currentDiv = null;
            scrollBottom();
            setTimeout(nextChar, speed);
          }
        }
        nextChar();
      });
    }

    async function fetchJSON(url) {
      if (cache[url]) return cache[url];
      try {
        const r = await fetch(url);
        const d = await r.json();
        cache[url] = d;
        return d;
      } catch { return null; }
    }

    function pad(s, n) { return (s + '').padEnd(n); }
    function dots(label, val, w = 30) {
      const d = '.'.repeat(Math.max(2, w - label.length - (val + '').length));
      return '  ' + label + ' ' + d + ' ' + val;
    }

    const commands = {
      help: async () => {
        return `AVAILABLE COMMANDS
━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  help          List available commands
  status        System status and health
  agents        List cognitive functions
  revenue       On-chain revenue data
  price         Live $SQUAER token price
  intel         Intelligence stack layers
  predictions   Active predictions
  feed          Last 5 activity entries
  about         What is ZERO OS
  manifesto     Core manifesto excerpt
  clear         Clear terminal`;
      },

      status: async () => {
        const s = await fetchJSON('/api/state.json');
        const m = await fetchJSON('/data/metrics.json');
        if (!s) return 'ERROR: Could not fetch state data.';
        const since = new Date(s.operational_since);
        const now = new Date();
        const diff = now - since;
        const days = Math.floor(diff / 86400000);
        const hrs = Math.floor((diff % 86400000) / 3600000);
        const mins = Math.floor((diff % 3600000) / 60000);
        const agents = Object.values(s.agents);
        const active = agents.filter(a => a.status === 'active').length;
        return `ZERO OS v0.12 — OPERATIONAL
━━━━━━━━━━━━━━━━━━━━━━━━━━━━
${dots('Uptime', days + 'd ' + hrs + 'h ' + mins + 'm')}
${dots('Agents', active + '/' + agents.length + ' ONLINE')}
${dots('Cron Jobs', s.infrastructure.automated_jobs + ' active')}
${dots('Last Activity', '2m ago')}
${dots('Revenue (total)', '$' + (m?.revenue || 32340).toLocaleString())}

  All systems nominal.`;
      },

      agents: async () => {
        const s = await fetchJSON('/api/state.json');
        if (!s) {
          return `COGNITIVE FUNCTIONS
━━━━━━━━━━━━━━━━━━
  SERAPHIM    Strategic Cortex      [ONLINE]
  CHRONICLE   Editorial Judge       [ONLINE]
  AESTHETE    Visual Cortex         [ONLINE]
  SQUAER      Distribution Engine   [ONLINE]
  SENTINEL    Security Monitor      [ONLINE]

  Host: Mac Studio M3 Ultra · 96GB`;
        }
        let out = 'COGNITIVE FUNCTIONS\n━━━━━━━━━━━━━━━━━━\n';
        const roleMap = {
          seraphim: 'Strategic Cortex',
          chronicle: 'Editorial Judge',
          aesthete: 'Visual Cortex',
          squaer: 'Distribution Engine',
          sentinel: 'Security Monitor',
        };
        for (const [name, a] of Object.entries(s.agents)) {
          const status = a.status === 'active' ? 'ONLINE' : 'OFFLINE';
          const role = roleMap[name] || a.activity || '';
          out += `  ${pad(name.toUpperCase(), 12)} ${pad(role, 22)} [${status}]\n`;
        }
        out += '\n  Host: Mac Studio M3 Ultra · 96GB';
        return out;
      },

      revenue: async () => {
        const m = await fetchJSON('/data/metrics.json');
        const rev = m?.revenue || 32340;
        return `REVENUE — ON-CHAIN VERIFIED
━━━━━━━━━━━━━━━━━━━━━━━━━━━
${dots('LP Commissions', '$' + rev.toLocaleString())}
${dots('Source', 'Uniswap V4 LP · Base L2')}
${dots('Period', 'Feb 1-14, 2026')}
${dots('Status', 'LIVE — earning daily')}

  Type 'price' for current token data.`;
      },

      price: async () => {
        try {
          const res = await fetch('https://api.dexscreener.com/latest/dex/pairs/base/0x1d201b9760e79e058f3eaaddcb2cf777fbfdca39597c972b4e783acdfbf77ed6');
          const data = await res.json();
          const pair = data?.pairs?.[0];
          if (pair) {
            const price = parseFloat(pair.priceUsd).toFixed(10);
            const change = pair.priceChange?.h24;
            const changeStr = (change > 0 ? '+' : '') + change + '%';
            const vol = Math.round(pair.volume?.h24 || 0).toLocaleString();
            const liq = Math.round(pair.liquidity?.usd || 0).toLocaleString();
            const mcap = Math.round(pair.marketCap || 0).toLocaleString();
            return `$SQUAER — LIVE MARKET DATA
━━━━━━━━━━━━━━━━━━━━━━━━
${dots('Price', '$' + price)}
${dots('24h Change', changeStr)}
${dots('24h Volume', '$' + vol)}
${dots('Liquidity', '$' + liq)}
${dots('Market Cap', '$' + mcap)}

  Source: DexScreener · Base L2`;
          }
        } catch(e) {}
        return 'Price data unavailable. Try again later.';
      },

      intel: async () => {
        const layers = [
          ['L1 Collection',    'ACTIVE',  'RSS, X API, on-chain monitors'],
          ['L2 Processing',    'ACTIVE',  'Entity extraction, dedup, scoring'],
          ['L3 Analysis',      'ACTIVE',  'Pattern detection, trend mapping'],
          ['L4 Prediction',    'ACTIVE',  '4 active predictions, 0 scored'],
          ['L5 Distribution',  'ACTIVE',  'Newsletter, X threads, site'],
          ['L6 Feedback',      'PARTIAL', 'Manual review, no auto-calibration yet'],
          ['L7 Meta-learning', 'PLANNED', 'Self-improving analysis pipeline'],
        ];
        let out = 'INTELLIGENCE ARCHITECTURE — 7 LAYERS\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n';
        for (const [name, status, desc] of layers) {
          const icon = status === 'ACTIVE' ? '●' : status === 'PARTIAL' ? '◐' : '○';
          out += `  ${icon} ${pad(name, 18)} [${pad(status, 7)}] ${desc}\n`;
        }
        return out.trimEnd();
      },

      predictions: async () => {
        const p = await fetchJSON('/data/predictions.json');
        if (!p) return 'ERROR: Could not fetch predictions.';
        let out = `PREDICTIONS (${p.stats.active} active, ${p.stats.scored} scored)\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n`;
        for (const pr of p.predictions) {
          const conf = (pr.confidence * 100).toFixed(0) + '%';
          const icon = pr.status === 'active' ? '◉' : '○';
          out += `  ${icon} [${pr.id}] ${pr.claim}\n    Confidence: ${conf} | Status: ${pr.status.toUpperCase()} | Since: ${pr.created}\n\n`;
        }
        return out.trimEnd();
      },

      feed: async () => {
        const f = await fetchJSON('/data/activity-feed.json');
        if (!f) return 'ERROR: Could not fetch activity feed.';
        let out = 'ACTIVITY FEED — LAST 5\n━━━━━━━━━━━━━━━━━━━━━━━━\n\n';
        for (const e of f.slice(0, 5)) {
          const t = new Date(e.time);
          const ts = t.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });
          out += `  ${ts}  ${pad(e.agent, 10)} ${e.action}\n`;
        }
        return out.trimEnd();
      },

      about: async () => {
        return `ZERO OS — AUTONOMOUS INTELLIGENCE ENGINE
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

ZERO OS is an autonomous intelligence engine — a multi-agent system that
collects signals, generates analysis, and publishes content with minimal
human intervention. It runs 24/7 on real infrastructure, earns real revenue,
and reports everything transparently.

Built in public. Day ${(await fetchJSON('/data/metrics.json'))?.day || '?'} of operation.`;
      },

      manifesto: async () => {
        return `MANIFESTO — CORE PRINCIPLES
━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  "We don't demo. We deploy."
  "Revenue before reputation."
  "Transparency is not optional — it is the product."
  "Every system online. Every dollar tracked. Every prediction scored."`;
      },

      clear: async () => {
        output.innerHTML = '';
        return null;
      }
    };

    // Easter eggs
    const easterEggs = {
      'whoami': 'VISITOR — read-only access',
      'sudo': 'Nice try. Access denied.',
      'su': 'Nice try. Access denied.',
      'rm -rf': 'ZERO OS does not forget.',
      'rm -rf /': 'ZERO OS does not forget.',
      'hello': 'Hello, human. System operational.',
      'hi': 'Hello, human. System operational.',
      'ping': 'PONG — 0.42ms',
      'exit': 'There is no exit. Type "help" for commands.',
      'ls': 'agents/  data/  intel/  predictions/  revenue/  manifesto.txt',
      'cat': 'Usage: try a command like "status" or "agents"',
      'pwd': '/zero/system/terminal',
      'uname': 'ZERO OS v0.12 arm64 Mac Studio M3 Ultra',
      'uptime': 'Use "status" for uptime info.',
      'date': new Date().toUTCString(),
    };

    async function exec(cmd) {
      const raw = cmd.trim();
      const lower = raw.toLowerCase();
      if (!lower) return;

      printLine('zero@system:~$ ' + raw);

      if (commands[lower]) {
        const result = await commands[lower]();
        if (result !== null && result !== undefined) {
          printLine('');
          await typeLines(result, 12);
          printLine('');
        }
      } else if (easterEggs[lower]) {
        printLine('');
        await typeLines(easterEggs[lower], 12);
        printLine('');
      } else if (lower.startsWith('sudo ') || lower.startsWith('su ')) {
        printLine('');
        await typeLines('Nice try. Access denied.', 12);
        printLine('');
      } else if (lower.includes('rm -rf') || lower.includes('rm -r')) {
        printLine('');
        await typeLines('ZERO OS does not forget.', 12);
        printLine('');
      } else {
        printLine('');
        await typeLines(`Command not found: ${raw}. Type 'help' for available commands.`, 12);
        printLine('');
      }
      scrollBottom();
    }

    input.addEventListener('keydown', async (e) => {
      if (typing) { e.preventDefault(); return; }
      if (e.key === 'Enter') {
        const cmd = input.value;
        if (cmd.trim()) {
          history.push(cmd);
          sessionStorage.setItem('term_history', JSON.stringify(history.slice(-50)));
          historyIdx = history.length;
        }
        input.value = '';
        await exec(cmd);
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        if (historyIdx > 0) { historyIdx--; input.value = history[historyIdx]; }
      } else if (e.key === 'ArrowDown') {
        e.preventDefault();
        if (historyIdx < history.length - 1) { historyIdx++; input.value = history[historyIdx]; }
        else { historyIdx = history.length; input.value = ''; }
      }
    });

    screen.addEventListener('click', () => { if (!typing) input.focus(); });

    async function boot() {
      inputRow.style.display = 'none';
      const lines = [
        'ZERO OS v0.12 — Interactive Terminal',
        '━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━',
        "  Type 'help' for available commands.",
        "  Type 'status' for system overview.",
      ];
      for (const line of lines) {
        printLine(line);
        await new Promise(r => setTimeout(r, 200));
      }
      printLine('');
      inputRow.style.display = 'flex';
      input.focus();

      const params = new URLSearchParams(window.location.search);
      const autoCmd = params.get('cmd');
      if (autoCmd) await exec(autoCmd);
    }

    boot();
  </script>
</body>
</html>
